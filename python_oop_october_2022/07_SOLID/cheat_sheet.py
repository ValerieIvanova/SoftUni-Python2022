# Single responsibility:
#   - Един обект клас, трябва да бъде отговорен само за една специфична функция
#     и трябва да има само една причина да бъде променян
#
# Open/Closed:
#   - Един клас трябва да бъде отворен за екстендване, но затворен за променяне
#     по-този начин си подсигуряваме работещ код, който не изисква рефакториране
#
# Liskov substitution:
#   - класовете, които се наследяват трябва да са взаимно заменяеми
#   - тоест, наследяващия клас трябва да правят еднакви неща, тоест абстракция
#   - това се получава с разширяване на бейс класа.
#   - усещаме се, че нарушаваме принципа, като имаме методи на клас, които реално той не може/не трябва да има
#
# Interface Segregation:
#   - основната идея е да нямаме методи, които не използваме,
#   - това в пайтън можем да постигнем, чрез миксини
#
# Dependency inversion:
#   - трябва да пазим бащиния клас да не знае нищо за класа, който го наследява
#   - детайлите зависят на абстракцията, а не абстракцията на детайлите
#   - тоест примерно не проверяваме в парент класа isinstance
#   - тоест парента не знае нищо за наследниците
#
# Dependency Injection - подчаст на Dependency Inversion
#   - инжектираме готова инстанция в класа, въпрос на контекст е дали в метод или инит